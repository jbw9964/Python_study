

문제 1 : 하노이의 탑 문제 - N 층의 하노이 탑을 이동시키기 위한 이동 순서를 나타내어라

[해결 방안] : Dynamic programming

배열 D 를 정의한다.
D[i] 에는 하노이의 탑이 i 만큼 쌓여져 있을 때, 움직여야 되는 순서가 저장되어 있다.

D[1] 은 1 이고 D[2] 는 1, 2, 1 인걸 쉽게 알 수 있으므로 이를 초기화 시킨다.

D = [[0] for _ in range(N + 1)]
D[1] = [1]
D[2] = [1, 2, 1]

N 층의 하노이의 탑을 움직이기 위해서는 N - 1 층의 하노이의 탑을 옮기고 N 번째 층을 옮긴다음
N - 1 층을 한번 더 움직여야 한다.
이를 토대로 D[N] 까지 배열을 초기화 시킨다.

for i in range(3, N + 1) : 

    D[i] = [v for v in D[i - 1]]        # N - 1 층 옮김
    D[i].append(i)                      # N 층 옮김
    
    for sequence in D[i - 1] :          # N - 1 층 다시 옮김
        D[i].append(sequence)

위 과정을 거치면 D[N] 에는 N 층의 하노이의 탑을 옮기기 위한 순서가 저장되고, 이를 문제의 조건에 따라 출력하면 된다.


문제 2 : 소수 문제 - N 보다 작은 소수들을 모두 나타내어라

[해결 방안] : Dynamic programming (에라토스테네스의 체)

소수를 판별하는 방법 중 하나인 에라토스테네스의 체 방법을 사용한다. 에라토스테네스의 체 방법은 쉽게말해 소수의 배수들을 모두 지우는 방법이다.
1을 제외한 주어진 숫자 N 까지 모든 수를 적고 숫자 2 부터 소수인지 아닌지 판별한다.
만약 확인하는 수 i 가 소수라면 N 까지의 수 중, i 의 배수들은 소수가 아니므로 이를 지운다.
N 까지 위 과정을 거치고 남은 수들은 소수이다.

위 방법을 구현하기 위해 D 배열을 정의한다.

D = [True for _ in range(N + 1)]

D[i] 는 숫자 i 가 소수이면 True, 아니라면 False 가 들어있는 배열이다.

숫자 2 부터 시작해 N 까지 에라토스테네스의 체 방법을 진행한다.
지금 확인하는 수 i 가 소수라면 N 까지의 수 중 i 의 배수들을 모두 False 처리한다.

for i in range(2, N + 1) : 
    if D[i] :                           # i 가 소수
        for j in range(2, N // i + 1) : 
            D[j * i] = False            # j * i = i 의 배수

위 과정을 거치면 D 배열에 True 가 지정된 수들은 모두 소수이므로, 숫자 2 부터 True 인 수들을 출력한다.