

문제 1 : infix to postfix 문제 - 주어진 문자열을 postfix notation 으로 나타내고 이를 계산하여라

[해결 방안] : Queue, Stack

Queue, Stack 자료구조를 이용해 infix notation 문자열을 postfix 로 바꿀 수 있다.
Queue 자료구조는 대표적인 FIFO 성질의 자료구조이고, Stack 자료구조는 LIFO 성질의 자료구조이다.
(First In First Out, Last In First Out)

postfix 로 바꾸기 전에 몇가지 유의사항이 있다. 다음과 같은 infix notation 문자열을 생각해보자.

1 * 2 + 3 / ( 4 + 3 * 2 )
1 2 * 3 4 3 2 * + / + 

위 식을 계산할 때 몇가지 우선순위가 있다. 1순위는 () 안에 있는 계산이고, 2순위는 */ 인 걸 알 수 있다.
3순위는 +- 계산인 걸 알 수 있다.

이 점을 유의하며 postfix notation 으로 바꾸기 위한 규칙을 설정하면 다음과 같다.
1. 입력받은 문자열을 Queue 에 넣은 후, 하나씩 pop 시키며 생각한다. pop 시킨 문자를 text 라 하자.
2. text 가 숫자일 경우 Postfix_string 에 넣는다.
3. text 가 연산자일 경우 Stack 에 넣어야 한다.
4. text 가 연산자 중 +,-,*,/ 이면, Stack 내부의 연산자 중 자신보다 높거나 같은 우선순위를 가진 연산자들은 모두 pop 시켜 Postfix_string 에 넣어야 한다.
5. text 가 ( 이면 그냥 Stack 에 넣고, ) 이면 pop 된 연산자가 ( 일 때까지 Stack 을 pop 시켜 Postfix_string 에 넣어야 한다.
6. 모든 text 를 둘러보았을 때, Stack 내부에 남아있는 연산자들을 모두 Postfix_string 에 넣는다.

이를 구현하면 연산의 우선순위를 (), */, +- 순으로 구현할 수 있다.
편의를 위해 이를 infix_to_postfix_re.py 에 따로 구현하였다.

infix_to_postfix_re.py 의 infix_to_postfix_fun() 을 보면 다음과 같다.

#====================================================================================================#
def infix_to_postfix_fun() -> list : 
    
    # 1. 입력받은 문자열을 Queue 에 넣은 후, 하나씩 pop 시키며 생각한다. pop 시킨 문자를 text 라 하자.
    infix_string = deque(map(str, input().split()))

    Postfix_string = []

    Stack = []

    while infix_string : 
        text = infix_string.popleft()
        
        #---------------------------------------------------------------#
        # 3. text 가 연산자일 경우 Stack 에 넣어야 한다.
        # 4. text 가 연산자 중 +,-,*,/ 이면, Stack 내부의 연산자 중 자신보다 높거나 같은 우선순위를 가진 연산자들은 모두 pop 시켜 Postfix_string 에 넣어야 한다.

        if text in '+-*/' :                     # text = operator except ()
            
            if text in '+-' :                   # text = +,-
                
                while Stack :                   # every operator in Stack has to be poped into Postfix string
                    in_stack = Stack.pop()

                    if in_stack in '()' :       # there was () in Stack
                        Stack.append(in_stack)
                        break
                    
                    else : 
                        Postfix_string.append(in_stack)

                Stack.append(text)
            
            else :                              # text = *,/

                while Stack :                   # every operator in Stack has to be poped into Postfix string except + or -
                    in_stack = Stack.pop()

                    if in_stack in '()' :       # there was () in Stack
                        Stack.append(in_stack)
                        break
                    
                    if in_stack in '+-' :       # in_stack = +,-
                        Stack.append(in_stack)
                        break
                    else :                      # in_stack = *,/
                        Postfix_string.append(in_stack)
                    
                Stack.append(text)
        
        #---------------------------------------------------------------#
        # 5. text 가 ( 이면 그냥 Stack 에 넣고, ) 이면 pop 된 연산자가 ( 일 때까지 Stack 을 pop 시켜 Postfix_string 에 넣어야 한다.

        elif text == '(' :                      # text = (
            Stack.append(text)
        elif text == ')' :                      # text = )
            
            while True :                        # every operator in Stack has to be poped into Postfix string untill ()
                in_stack = Stack.pop()
                
                if in_stack in '()' :           # in_stack = ()
                    break
                else : 
                    Postfix_string.append(in_stack)

        #---------------------------------------------------------------#
        # 2. text 가 숫자일 경우 Postfix_string 에 넣는다.

        else :                                  # text = number
            Postfix_string.append(int(text))

        #---------------------------------------------------------------#
        # end while

    # 6. 모든 text 를 둘러보았을 때, Stack 내부에 남아있는 연산자들을 모두 Postfix_string 에 넣는다.

    while Stack : 
        in_stack = Stack.pop()
        Postfix_string.append(in_stack)

    return Postfix_string
#====================================================================================================#

위 함수를 이용해 infix notation 문자열을 postfix 로 바꾸었으므로,
이제 postfix notation 문자열을 계산하면 된다.

postfix notation 문자열을 계산하는 규칙은 다음과 같다.
1. postfix 문자열을 처음부터 끝까지 읽어 나간다. 만난 문자를 text 라 하자.
2. text 가 숫자일 경우 Stack 에 넣는다.
3. text 가 연산자일 경우, Stack 에서 2 개를 pop 해 서로 연산을 진행하고 결과를 다시 Stack 에 넣는다.
4. postfix 문자열을 끝까지 읽은 후 Stack 에 남아있는 숫자가 게산 결과이다.

이를 구현한 postfix_calc_fun 은 다음과 같다.

#====================================================================================================#
def postfix_calc_fun(Postfix : list) -> int :
    Stack = []

    for text in Postfix : 
        
        #------------------------------------------------------------#
        # 3. text 가 연산자일 경우, Stack 에서 2 개를 pop 해 서로 연산을 진행하고 결과를 다시 Stack 에 넣는다.

        if type(text) == str :                              # num_1 num_2 (text) --> num_1 (text) num_2
            num_2 = Stack.pop()
            num_1 = Stack.pop()
            
            if text == '+' : Stack.append(num_1 + num_2)
            elif text == '-' : Stack.append(num_1 - num_2)
            elif text == '*' : Stack.append(num_1 * num_2)
            else : Stack.append(num_1 / num_2)              # a b / --> a / b
        
        #------------------------------------------------------------#
        # 2. text 가 숫자일 경우 Stack 에 넣는다.

        else : 
            Stack.append(int(text))
        
        #------------------------------------------------------------#
        # end for
        
    return Stack[0]
#====================================================================================================#

위 두 함수를 이용해 문제의 조건에 맞게 출력하면 된다.


문제 2 : 그래프 사이클 여부 문제 - 주어진 그래프에 사이클 존재 여부를 판별하여라

[해결 방안] : Depth first search

문제를 보면 주어진 그래프는 방향 그래프 (Digraph) 인 것을 알 수 있다.
무방향 그래프인 경우 union-find 방식으로 그래프의 사이클을 참지할 수 있지만 방향 그래프는 
이를 적용할 수 없다. 대신 깊이우선 탐색을 통해 사이클을 탐지할 수 있다.

다음과 같은 방향 그래프에서 깊이 우선 탐색을 진행하여 보자.

(A)                             (B)
(1) --> (2) --> (3)             (1) --> (2) --> (3)
         ↓       ↑                       ↑       ↓
         ↓       ↑                       ↑       ↓
        (4) --> (5)                     (4) <-- (5)

(1) Node 에서 깊이 우선 탐색을 진행해 보면, A 는 (1)-(2)-(3)-(4)-(5)-(3) 순으로 진행하고
B 는 (1)-(2)-(3)-(5)-(4)-(2)-... 로 진행한다. 이 때 A 의 (3) Node 와 B 의 (2) Node 를 주목하라.

B 에는 사이클이 존재하여 (2) Node 를 2번 이상 방문하였다. 하지만 A 에는 사이클이 존재하지 않음에도 불구하고,
방향 그래프와 깊이우선 탐색의 성질 때문에 (3) Node 를 2번 방문하였다.
위 두 상황을 구별하는것은 매우 중요하다.

때문에 이를 구별하기 위한 Process_table 을 만들었다.
사이클이 존재한다면 깊이우선 탐색이 행해지는 도중에 방문했던 정점을 다시 방문해야 한다.
이를 다음과 같이 구현하였다.

#====================================================================================================#
for V in range(N) : 
    
    Visit_table = [False for i in range(N)]
    Process_table = [False for i in range(N)]
    
    Cycle = DFS(Visit_table, Process_table, E, V, N)
    
    if Cycle == 1 : break

def DFS(Visit_table : list, Process_table : list, E : list, V : int, N : int) -> int : 
    
    if Visit_table[V] and Process_table[V] : return True

    Visit_table[V] = True
    Process_table[V] = True
    Result = False
    for i in range(N) : 
        if E[V][i] == 1 : 
            Result = DFS(Visit_table, Process_table, E, i, N)
            Visit_table[i] = False
            Process_table[i] = False
    
    return Result
#====================================================================================================#

각 정점마다 Visit_table, Process_table 을 초기화시켰고 깊이우선 탐색을 진행해 사이클이 존재하는지 확인하였다.

깊이우선 탐색이 행해진 정점은 아래와 같이 초기화 하여 방문여부와 깊이우선 탐색 실행 여부를 저장하였다.

Visit_table[V] = True
Process_table[V] = True

그리고 인접한 정점에 대해서도 깊이우선 탐색을 진행하였다.

Result = False
for i in range(N) : 
    if E[V][i] == 1 : 
        Result = DFS(Visit_table, Process_table, E, i, N)

이 때 만약 방문했던 정점을 다시 방문하고, 해당 정점에 대해서 깊이우선 탐색이 진행중이었다면,
그래프 내부에 사이클이 존재하는 것이므로 True 리턴하였다.

if Visit_table[V] and Process_table[V] : return True

이를 진행하면 결국 그래프에 사이클이 존재한다면 Result = True, 그렇지 않다면 Result = False 로 초기화된다.
또한 Result = DFS(Visit_table, Process_table, E, i, N) 를 지나면
해당 정점에 대해서 깊이우선 탐색이 끝난 것 이므로 아래와 같이 Process_table 을 다시 초기화 시켜준다.

        Visit_table[i] = False
        Process_table[i] = False

이를 각 정점에 대해 진행하면 사이클 존재 여부를 알 수 있다.
